/**
 * Player class reads handles password specification blueprints (JSON-String) and the password generator
 * Created by crystalneth on 10-Jun-17.
 */
/* exported Player */
class Player {

    /**
     * Constructor for a player object. Note that the constructor immediately checks,
     * whether the provided blueprint-string is a valid JSON-Password Composition Policy or not.
     *
     * @param blueprintJson password policy specification blueprint (JSON String)
     * @param schema JSON String containing JSON schema for password policies
     */
    constructor(blueprintJson, schema) {
        this.schema = JSON.parse(schema);
        this.blueprint = this._parseBlueprint(blueprintJson);
    }

    /**
     * Validates the password policy blueprint against the Password Composition Policy schema.
     *
     * @param blueprintJson JSON String of the password composition policy blueprint.
     * @returns {Object} the parsed blueprint as object.
     * @private
     */
    _parseBlueprint(blueprintJson) {
        const ajv = new Ajv();
        const validate = ajv.compile(this.schema);
        const blueprint = JSON.parse(blueprintJson);

        if (validate(blueprint)) {
            return blueprint;
        } else {
            throw new Error('Blueprint doesn\'t follow JSON schema');
        }
    }

    /**
     * Invokes the password generator to generate a Password with the specified maximum length and allowed character set, which are specified in the blueprint
     *
     * @returns {Promise} password generated by the password generator.
     * @private
     */
    _invokePasswordGenerator() {
        const passwordGenerator = new PasswordGen();
        let maxLength = this.blueprint.pwdPolicy[0].maxLength;
        let arrayOfChars = [];
        let RequirementSet = this.blueprint.pwdPolicy[0].compositionRequirements;
        let characterSets = this.blueprint.pwdPolicy[0].allowedCharacterSets;

        for(let charSetId of Object.keys(characterSets)){

            //the password generator doesn't use a single unicode charset, so we need to add all of them separately
            if(charSetId=='unicode'){
                arrayOfChars.push({char: 'umlauts', min: 0 });
                arrayOfChars.push({char: 'currency', min: 0 });
                arrayOfChars.push({char: 'arrow', min: 0 });
                arrayOfChars.push({char: 'mathsymbols', min: 0 });
                arrayOfChars.push({char: 'pictographs', min: 0 });
                arrayOfChars.push({char: 'emoji_common', min: 0 });
            }
            let charSet = {char: characterSets[charSetId], min: 0 };

            // we search the composition Requirements for the required minimum number of each charset, if nothing is found we assume 0
            for(let RequirementSetItem of RequirementSet){
                let charSetEx= '.*['+ charSetId +'].*';

                if(charSetEx == RequirementSetItem.rule.regexp){
                    charSet.min = RequirementSetItem.num;
                }
            }
            arrayOfChars.push(charSet);
        }



        return passwordGenerator.generatePassword(maxLength, arrayOfChars).then(function (result) {
            return result;
        });
    }

    /**
     * This method is used to validate the passwords generated by the Password Generator.
     * Only the position specific and custom requirements need to be checked.
     * Tests the password on the Regular Expressions contained in the blueprint, that specify the password composition policies.
     * Especially those who are not guaranteed by the password generator, like position requirements.
     * Stops after the first failed Regular Expression.
     *
     * @param password {String}  Password to be tested
     * @param username (String)  for restricting the password not to be the username
     * @returns {boolean} true if the password satisfies the policies, false if one or more policies are not satisfied
     *
     * @private
     */
    _validatePassword(password, username) {
        let pwdPolicy = this.blueprint.pwdPolicy[0];
        let maxLength = pwdPolicy.maxLength;

        //The Generator uses several characters, that are interpreted as 2 characters by some websites, i.e. github.com,
        //because they consist of multiple code points. With Array.from(password).length all code points in the password are counted
        if (Array.from(password).length> maxLength) {
            return false;
        }

        //for every character set there is a requirement, to specify if a minimum amount of those characters is needed.
        //These contain identifiers as rules, so we skip them
        let skip = 0;
        for (let requirement of pwdPolicy.compositionRequirements) {
            if(skip >= (Object.keys(this.blueprint.pwdPolicy[0].allowedCharacterSets).length)) {
                if (!this._test(password, requirement, pwdPolicy.allowedCharacterSets, username)) {
                    return false;
                }
            }
            skip+=1;
        }
        return true;
    }

    /**
     * Tests the password on the passed regular expression requirement, with respect to the allowed  Character Sets.
     *
     * @param password {String}  the password to be tested
     * @param requirement {Array}  a regular expression
     * @param allowedCharacterSets {Object}  the allowed character sets
     * @param username (String)  for restricting the password not to be the username
     * @returns {boolean} only true if the password meets the specified requirements
     * @private
     */
    _test(password, requirement, allowedCharacterSets, username) {
        let regExp = requirement.rule.regexp;
        regExp = regExp.replace('[username]', username);


        const az = allowedCharacterSets.az;
        const AZ = allowedCharacterSets.AZ;
        const num = allowedCharacterSets.num;
        const special = allowedCharacterSets.special;
        const passwords = ['012345678', 'password', 'asdf', 'test', 'P@ssword123'];

        regExp = regExp.replace('az', az);
        regExp = regExp.replace('AZ', AZ);
        regExp = regExp.replace('num', num);
        regExp = regExp.replace('special', special);


        if (regExp.includes('[password]')) {
            let newValue = '(';
            for (let pw of passwords) {
                newValue += pw + '|';
            }
            newValue = newValue.substr(0, newValue.length - 1) + ')';
            regExp = regExp.replace('[password]', newValue);
        }

        regExp = new RegExp(regExp, 'g');
        let result = regExp.test(password);
        if (requirement.kind === 'must') {
            return result;
        } else {
            return !result;
        }
    }

    /**
     * Tests the password on all the Regular Expressions contained in the blueprint, that specify the password composition policies.
     * Collects the descriptions of the failed requirements in an array and returns them.
     * Also returns a boolean that is true, if no requirement was failed, and is false otherwise.
     *
     * @param password {String}  the password to be tested
     * @param username (String)  for restricting the password not to be the username
     * @returns {{sat: boolean, failReq: Array, passReq: Array}} sat= boolean, true if the password satisfies all requirements specified in the blueprint.
     *                                                           failReq= an array filled with textual descriptions of the unsatisfied requirements as strings.
     *                                                           passReq= an array filled with textual descriptions of all satisfied requirements. Always contains a description of which characters are not allowed.
     */
    validateUserPassword(password, username) {
        let pwdPolicy = this.blueprint.pwdPolicy[0];
        let characterSets = this.blueprint.pwdPolicy[0].allowedCharacterSets;
        let unSatReq = [];
        let satReq = [];
        let satisfied = true;
        let minLength = pwdPolicy.minLength;
        let maxLength = pwdPolicy.maxLength;

        //Array.from().length to count characters in Strings containing Unicode reliably.
        // Characters like nÌƒ (n\u0303) still count as 2 characters, as sites like github.com do the same.
        if (Array.from(password).length< minLength) {
            satisfied = false;
            unSatReq.push(chrome.i18n.getMessage('contain-at-least') + ' ' + minLength + ' ' + chrome.i18n.getMessage('characters')+'.');
        } else {
            satReq.push(chrome.i18n.getMessage('contain-at-least') + ' ' + minLength + ' ' + chrome.i18n.getMessage('characters')+'.');
        }

        if (Array.from(password).length> maxLength) {
            satisfied = false;
            unSatReq.push(chrome.i18n.getMessage('contain-max')+ ' ' + maxLength + ' ' + chrome.i18n.getMessage('characters')+ '.');
        } else {
            satReq.push(chrome.i18n.getMessage('contain-max') + ' ' + maxLength + ' ' + chrome.i18n.getMessage('characters')+ '.');
        }

        let allowedChars = '';
        let unicodeAllowed = false;

        for(let charSet in characterSets){


            if(!(charSet == 'unicode')){
                allowedChars += characterSets[charSet].replace(/\\/,'\\\\').
                replace(/\[/g, '\\[').
                replace(/]/g, '\\]').
                replace(/\^/g, '\\^').
                replace(/\$/g, '\\$').
                replace(/-/g, '\\-');


            } else {
                unicodeAllowed = true;
            }
        }

        let charExp = new RegExp('[^' + allowedChars + ']');
        charExp = new RegExp(charExp, 'gu');
        let check;
        if(unicodeAllowed){
            check = password.replace(/[^\u0020-\u007E]/gu,'').match(charExp);
        } else {
            check = password.match(charExp);
        }



        if (check !== null) {
            satisfied = false;
            check = [...new Set(check)];//.toString();
            unSatReq.push( chrome.i18n.getMessage('do-not-use') + check + chrome.i18n.getMessage('in-your-password'));
        }

        // this tells the User which ASCII characters he may not use in his password
        let ascii = '\'!"#$%&()*+,-./:;<=>?@{|}~0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz';
        ascii = ascii.match(charExp);
        if (ascii !== null) {
            ascii = [...new Set(ascii)].toString();
            satReq.push( chrome.i18n.getMessage('do-not-use') + ascii + chrome.i18n.getMessage('in-your-password'));
        }


        let skip = 0;
        for (let requirement of pwdPolicy.compositionRequirements) {
            if(skip>=(Object.keys(this.blueprint.pwdPolicy[0].allowedCharacterSets).length)) {
                if (!this._test(password, requirement, pwdPolicy.allowedCharacterSets, username)) {
                    satisfied = false;
                    unSatReq.push(requirement.rule.description);
                } else {
                    satReq.push(requirement.rule.description);
                }

            }
            skip +=1;

        }
        return {sat: satisfied, failReq: unSatReq, passReq: satReq};
    }

    _generateDescription(descriptionStr,number){

        let descArr = descriptionStr.splice(' ');
        let description = '';
        let ids = new Set(['capital','lowercase','number','special' ]);

        if(ids[0]== 'Custom:'){
            return descriptionStr.replace('Custom:','');

        }

        for(let id in descArr){

            if(id === 'num'){
                description += number;
            }

            if(browser.i18n.getMessage(id) == ''){
                description+= id;
            } else{
                description+= browser.i18n.getMessage(id);
            }



        }




    }

    /**
     * Generates a new password by using the PasswordGenerator and validating it against the blueprint
     *
     * @param username (String) for restricting the password not to be the username
     * @param timeout (Integer) timeout in seconds after which to stop trying to generate a valid password
     * @param start (Integer) start time of the first invocation in seconds
     * @returns {Promise} new, valid password
     */
    generatePassword(username, timeout = 5, start = new Date().getSeconds()) {
        //this is necessary because otherwise we wouldn't be able to access class methods(and variables like the blueprint) from within the then block.
        let store = this;


        //accesses the promise of the password generator and returns it if it contains a valid password

        return this._invokePasswordGenerator().then(function (val) {

            let result = store._validatePassword(val, username);
            if (result) {
                return val;
            }  else if(Math.abs(start - new Date().getSeconds()) > timeout){
                return '';
            } else {
                //returns a new valid password recursively if the first one wasn't valid

                return (store.generatePassword(username, timeout, start));
            }

        });
    }
}
