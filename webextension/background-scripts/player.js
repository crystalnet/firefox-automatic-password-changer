/**
 * Player class reads handles password specification blueprints (JSON-String) and the password generator
 * Created by crystalneth on 10-Jun-17.
 */
/* exported Player */
class Player {

    /**
     * Constructor for a player object. Note that the constructor immediately checks,
     * whether the provided blueprint-string is a valid JSON-Password Composition Policy or not.
     *
     * @param blueprintJson password policy specification blueprint (JSON String)
     * @param schema JSON String containing JSON schema for password policies
     */
    constructor(blueprintJson, schema) {
        this.schema = JSON.parse(schema);
        this.blueprint = this._parseBlueprint(blueprintJson);
    }

    /**
     * Validates the password policy blueprint against the Password Composition Policy schema.
     *
     * @param blueprintJson JSON String of the password composition policy blueprint.
     * @returns {Object} the parsed blueprint as object.
     * @private
     */
    _parseBlueprint(blueprintJson) {
        const ajv = new Ajv();
        const validate = ajv.compile(this.schema);
        const blueprint = JSON.parse(blueprintJson);

        if (validate(blueprint)) {
            return blueprint;
        } else {
            throw new Error('Blueprint doesn\'t follow JSON schema');
        }
    }

    /**
     * Invokes the password generator to generate a Password with the specified maximum length and allowed character set, which are specified in the blueprint.
     *
     *
     * @returns {Promise} password generated by the password generator.
     * @private
     */
    _invokePasswordGenerator() {
        const passwordGenerator = new PasswordGen();
        let maxLength = this.blueprint.pwdPolicy[0].maxLength;
        let arrayOfChars = [];
        let RequirementSet = this.blueprint.pwdPolicy[0].compositionRequirements;
        let characterSets = this.blueprint.pwdPolicy[0].allowedCharacterSets;

        for(let charSetId of Object.keys(characterSets)){

            //the password generator doesn't use a single unicode charset, so we need to add all of them separately
            if(charSetId=='unicode'){
                arrayOfChars.push({char: 'umlauts', min: 0 });
                arrayOfChars.push({char: 'currency', min: 0 });
                arrayOfChars.push({char: 'arrow', min: 0 });
                arrayOfChars.push({char: 'mathsymbols', min: 0 });
                arrayOfChars.push({char: 'pictographs', min: 0 });
                arrayOfChars.push({char: 'emoji_common', min: 0 });
            }
            let charSet = {char: characterSets[charSetId], min: 0 };

            // we search the composition Requirements for the required minimum number of each charset by searching for the specific rule, if nothing is found we assume 0
            for(let RequirementSetItem of RequirementSet){
                let minRegExp = new RegExp('^\\^\\(\\(\\[\\^'+charSetId+'\\]\\*\\)\\['+charSetId+'\\]\\(\\[\\^'+charSetId+'\\]\\*\\)\\)\\{[0-9]*,\\}\\$$');

                if(minRegExp.test(RequirementSetItem.rule.regexp)){
                    charSet.min = RequirementSetItem.num;
                }
            }
            arrayOfChars.push(charSet);
        }



        return passwordGenerator.generatePassword(maxLength, arrayOfChars).then(function (result) {
            return result;
        });
    }

    /**
     * This method is used to validate the passwords generated by the Password Generator.
     * Only the position specific and custom requirements need to be checked.
     * Tests the password on the Regular Expressions contained in the blueprint, that specify the password composition policies.
     * Especially those who are not guaranteed by the password generator, like position requirements.
     * Stops after the first failed Regular Expression.
     *
     * @param password {String}  Password to be tested
     * @param username (String)  for restricting the password not to be the username
     * @returns {boolean} true if the password satisfies the policies, false if one or more policies are not satisfied
     *
     * @private
     */
    _validatePassword(password, username) {
        let pwdPolicy = this.blueprint.pwdPolicy[0];
        let maxLength = pwdPolicy.maxLength;

        //The Generator uses several characters, that are interpreted as 2 characters by some websites, i.e. github.com,
        //because they consist of multiple code points. With Array.from(password).length all code points in the password are counted
        if (Array.from(password).length> maxLength) {
            return false;
        }

        for (let requirement of pwdPolicy.compositionRequirements) {
            if (!this._test(password, requirement, pwdPolicy.allowedCharacterSets, username)) {
                return false;
            }

        }
        return true;
    }

    /**
     * Tests the password on the passed regular expression requirement, with respect to the allowed  Character Sets.
     *
     * @param password {String}  the password to be tested
     * @param requirement {Array}  a regular expression
     * @param allowedCharacterSets {Object}  the allowed character sets
     * @param username (String)  for restricting the password not to be the username
     * @returns {boolean} only true if the password meets the specified requirements
     * @private
     */
    _test(password, requirement, allowedCharacterSets, username) {

        let regExp = requirement.rule.regexp;
        //Some special characters need to be escaped so that they don't interfere with the RegEx.
        if(regExp == '.*[username].*'){
            let escapedUsername = username.replace(/\\/, '\\\\').
            replace(/\[/g, '\\[').
            replace(/]/g, '\\]').
            replace(/\^/g, '\\^').
            replace(/\$/g, '\\$').
            replace(/-/g, '\\-').
            replace(/\(/g, '\\(').
            replace(/\)/g, '\\)').
            replace(/\*/g, '\\*').
            replace(/{/g, '\\{').
            replace(/\./g, '\\.').
            replace(/\+/g, '\\+').
            replace(/\?/g, '\\?').
            replace(/\|/g, '\\|');
            regExp = regExp.replace('[username]', escapedUsername);

        }

        //We replace all occurences of the identifiers in the RegEx with the corresponding character set
        // Some special characters need to be escaped so that they don't interfere with the RegEx.
        // The character sets are used as sets in [], thus only a few characters need to be replaced.

        for(let charSetId of Object.keys(allowedCharacterSets)){
            if(charSetId=='unicode'){
                continue;
            }
            let exp = new RegExp(charSetId, 'g');
            let charSet = allowedCharacterSets[charSetId].replace(/\\/,'\\\\').
            replace(/\[/g, '\\[').
            replace(/]/g, '\\]').
            replace(/\^/g, '\\^').
            replace(/\$/g, '\\$').
            replace(/-/g, '\\-');
            regExp = regExp.replace(exp, charSet);

        }

        // We have no access to previous passwords, so we ignore these requirements and remind the user to respect them.
        // The 5 pseudo passwords can be replaced with the real passwords, if those are accessible in the future.
        const passwords = ['012345678', 'password', 'asdf', 'test', 'P@ssword123'];
        if (regExp.includes('[password]')) {

            let newValue = '(';
            for (let pw of passwords) {
                newValue += pw + '|';
            }
            newValue = newValue.substr(0, newValue.length - 1) + ')';
            regExp = regExp.replace('[password]', newValue);
        }

        regExp = new RegExp(regExp, 'g');
        let result = regExp.test(password);
        // the kind of the property defines whether the RegExp must match or not.
        // e.g. If a the RegEx of a 'must' property doesn't match, the policy is considered unsatisfied.
        if (requirement.kind === 'must') {
            return result;
        } else {
            return !result;
        }
    }

    /**
     * Tests the password on all the Regular Expressions contained in the blueprint, that specify the password composition policies.
     * Collects the descriptions of the failed requirements in an array and returns them.
     * Also returns a boolean that is true, if no requirement was failed, and is false otherwise.
     *
     * @param password {String}  the password to be tested
     * @param username (String)  for restricting the password not to be the username
     * @returns {{sat: boolean, failReq: Array, passReq: Array}} sat= boolean, true if the password satisfies all requirements specified in the blueprint.
     *                                                           failReq= an array filled with textual descriptions of the unsatisfied requirements as strings.
     *                                                           passReq= an array filled with textual descriptions of all satisfied requirements. Always contains a description of which characters are not allowed.
     */
    validateUserPassword(password, username) {
        let pwdPolicy = this.blueprint.pwdPolicy[0];
        let characterSets = this.blueprint.pwdPolicy[0].allowedCharacterSets;
        let unSatReq = [];
        let satReq = [];
        let reminder = [];
        let satisfied = true;
        let minLength = pwdPolicy.minLength;
        let maxLength = pwdPolicy.maxLength;

        //Array.from().length to count characters in Strings containing Unicode reliably.
        // Characters like nÌƒ (n\u0303) still count as 2 characters, as sites like github.com do the same.
        if (Array.from(password).length< minLength) {
            satisfied = false;
            unSatReq.push(chrome.i18n.getMessage('contain-at-least') + ' ' + minLength + ' ' + chrome.i18n.getMessage('characters')+'.');
        } else {
            satReq.push(chrome.i18n.getMessage('contain-at-least') + ' ' + minLength + ' ' + chrome.i18n.getMessage('characters')+'.');
        }

        if (Array.from(password).length> maxLength) {
            satisfied = false;
            unSatReq.push(chrome.i18n.getMessage('contain-max')+ ' ' + maxLength + ' ' + chrome.i18n.getMessage('characters')+ '.');
        } else {
            satReq.push(chrome.i18n.getMessage('contain-max') + ' ' + maxLength + ' ' + chrome.i18n.getMessage('characters')+ '.');
        }

        //Here we construct a RegExp to check whether the user only used allowed characters in his password.
        //If Unicode is set to allowed, except if one was explicitly removed from the predefined character sets.
        let allowedChars = '';
        let unicodeAllowed = false;
        //collecting the predefined character sets
        for(let charSet in characterSets){
            if(!(charSet == 'unicode')){
                allowedChars += characterSets[charSet].replace(/\\/,'\\\\').
                replace(/\[/g, '\\[').
                replace(/]/g, '\\]').
                replace(/\^/g, '\\^').
                replace(/\$/g, '\\$').
                replace(/-/g, '\\-');
            } else {
                unicodeAllowed = true;
            }
        }
        //building the RegExp
        let charExp = new RegExp('[^' + allowedChars + ']');
        charExp = new RegExp(charExp, 'gu');
        let check;
        if(unicodeAllowed){
            check = password.replace(/[^\u0020-\u007E]/gu,'').match(charExp);
        } else {
            check = password.match(charExp);
        }
        //construct a message to tell the user which character/s in his chosen password are illegal
        if (check !== null) {
            satisfied = false;
            check = [...new Set(check)];//.toString();
            unSatReq.push( chrome.i18n.getMessage('do-not-use') + check + chrome.i18n.getMessage('in-your-password'));
        }

        // this tells the User which ASCII characters he may not use in his password
        let ascii = '\'!"#$%&()*+,-./:;<=>?@{|}~0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz';
        ascii = ascii.match(charExp);
        if (ascii !== null) {
            ascii = [...new Set(ascii)].toString();
            satReq.push( chrome.i18n.getMessage('do-not-use') + ascii + chrome.i18n.getMessage('in-your-password'));
        }


        //no we go through every composition requirement and test whether it's rule is satisfied or not
        //the descriptions contain identifiers that are parsed into a localized message
        for (let requirement of pwdPolicy.compositionRequirements) {
            //We cannot access the previous passwords of the user, so we just post a reminder
            if(requirement.rule.regexp === '.*[password].*'){
                reminder.push(this._generateDescription(requirement.rule.description));
                continue;
            }

            if (!this._test(password, requirement, pwdPolicy.allowedCharacterSets, username)) {
                satisfied = false;
                unSatReq.push(this._generateDescription(requirement.rule.description));
            } else {
                satReq.push(this._generateDescription(requirement.rule.description));
            }        }


        return {sat: satisfied, failReq: unSatReq, passReq: satReq, remindReq: reminder};
    }

    /**
     * * Takes a string containing identifiers, that are delimited by whitespaces.
     * Builds a localised message from the identifiers. The string will not be changed if the first
     * identifier is 'Custom: '.
     * @param descriptionArg (string) A string from a policy description, containing identifiers for localisation, or a Custom description, written by a user
     * @returns {string} A localised policy description.
     * @private
     */
    _generateDescription(descriptionArg){
        let descArr = descriptionArg.split(' ');
        let description = '';

        //if the first identifier is Custom:, the policy is a custom policy by the user and won't be translated.
        if(descArr[0] === 'Custom:'){
            return descriptionArg.substring(8);
        }

        for(let id of descArr){

            //if there is a corresponding locale it is added to the String, if not the identifier is a number or a specific
            //character set and is added directly to the string.
            let message = chrome.i18n.getMessage(id);
            if (message === ''){
                description += id;
            } else {
                description += chrome.i18n.getMessage(id);
            }
        }
        return description;
    }

    /**
     * Generates a new password by using the PasswordGenerator and validating it against the blueprint
     *
     * @param username (String) for restricting the password not to be the username
     * @param timeout (Integer) timeout in seconds after which to stop trying to generate a valid password
     * @param start (Integer) start time of the first invocation in seconds
     * @returns {Promise} new, valid password
     */
    generatePassword(username, timeout = 5, start = new Date().getSeconds()) {
        //this is necessary because otherwise we wouldn't be able to access class methods(and variables like the blueprint) from within the then block.
        let store = this;


        //accesses the promise of the password generator and returns it if it contains a valid password

        return this._invokePasswordGenerator().then(function (val) {

            let result = store._validatePassword(val, username);
            if (result) {
                return val;
            }  else if(Math.abs(start - new Date().getSeconds()) > timeout){
                return '';
            } else {
                //returns a new valid password recursively if the first one wasn't valid

                return (store.generatePassword(username, timeout, start));
            }

        });
    }
}
